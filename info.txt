

********* SPACE  UTILITY
L' spaceutilità può essere aggiunta a qualsiasi componente che accetti il className​​prop.

// example
import styled from 'styled-component'
import { space } from 'styled-system'

const Heading = styled.h2(space)
Quando si utilizza il componente, è possibile regolare il margine e il riempimento in qualsiasi direzione necessaria.

// example usage
<Heading mt={0} mb={4} pl={0}>
  Hello
</Heading>
********* SPACE  UTILITY


///********* DEFAULT PROPS
Diciamo che hai un componente Card che nove volte su dieci ha un padding specifico, ma ogni tanto devi cambiarlo. Per aggiungere un valore predefinito per qualsiasi prop di sistema in stile, utilizzalo defaultPropssul tuo componente.

// example
import styled from 'styled-components'
import { space, color } from 'styled-system'

const Card = styled.div(
  {
    borderRadius: '2px',
    boxShadow: '0 2px 4px rgba(0, 0, 0, 0.125)',
  },
  space,
  color
)

Card.defaultProps = {
  p: 2,
  bg: 'white',
}

export default Card
Con gli oggetti di scena predefiniti sopra, il componente della tua carta avrà un'imbottitura e uno sfondo bianco per impostazione predefinita. Puoi sovrascrivere questi stili quando necessario passando un sostegno al componente.

// example overriding default styles
<Card p={3} bg="lightgray">
  <Image />
  <Text />
</Card>
///********* DEFAULT PROPS



Theme Key	CSS Properties
space =	margin, margin-top, margin-right, margin-bottom, margin-left, padding, padding-top, padding-right, padding-bottom,padding-left, grid-gap, grid-column-gap, grid-row-gap
fontSizes =	font-size
colors =	color, background-color, border-color
fonts =	font-family
fontWeights =	font-weight
lineHeights =	line-height
letterSpacings =	letter-spacing
sizes =	width, height, min-width, max-width, min-height, max-height
borders =	border, border-top, border-right, border-bottom, border-left
borderWidths	border-width
borderStyles	border-style
radii =	border-radius
shadows =	box-shadow, text-shadow
zIndices =	z-index

/////////////////////////

Per me il problema si verificava durante l'esecuzione su WiFi, poiché gli strumenti utilizzano sempre la tua prima connessione (puoi verificarla eseguendo ipconfig) e la mia prima connessione è stata Internet.

Se questo è il tuo caso, puoi provare questa soluzione alternativa per modificare la priorità delle tue connessioni:

Vai su Pannello di controllo > Rete e Internet > Connessioni di rete
Fare clic con il pulsante destro del mouse sulla connessione desiderata (Connessione a priorità più alta)
Fare clic su Proprietà > Protocollo Internet versione 4
Fare clic su Proprietà > Avanzate
Deseleziona "Metrica automatica"
Inserisci 10 in "Metrica interfaccia"
Fare clic su OK

È passato un po 'di tempo da quando hai posto questa domanda, quindi presumo che tu abbia già capito la risposta. Devi cambiare lo script "start" in package.json in "expo start --tunnel".

  "scripts": {
    "start": "expo start --tunnel",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "eject": "expo eject"
  },

  ////////////////////////////////////////////

REACT NAVIGATION native
https://reactnavigation.org/docs/headers

Riassunto:
navigate e push accetta un secondo argomento facoltativo per consentirti di passare parametri alla rotta verso la quale stai navigando. Ad esempio: navigation.navigate('RouteName', { paramName: 'value' }).
Puoi leggere i parametri route.paramsall'interno di uno schermo
Puoi aggiornare i parametri dello schermo connavigation.setParams
I parametri iniziali possono essere passati tramite il initialParamsprop onScreen
I parametri dovrebbero contenere i dati minimi richiesti per mostrare uno schermo, niente di più

***************** ESEMPIO CREA POST:

import * as React from 'react';
import { Text, TextInput, View, Button } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';

function HomeScreen({ navigation, route }) {
  React.useEffect(() => {
    if (route.params?.post) {
      // Post updated, do something with `route.params.post`
      // For example, send the post to the server
    }
  }, [route.params?.post]);

  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Button
        title="Create post"
        onPress={() => navigation.navigate('CreatePost')}
      />
      <Text style={{ margin: 10 }}>Post: {route.params?.post}</Text>
    </View>
  );
}

function CreatePostScreen({ navigation, route }) {
  const [postText, setPostText] = React.useState('');

  return (
    <>
      <TextInput
        multiline
        placeholder="What's on your mind?"
        style={{ height: 200, padding: 10, backgroundColor: 'white' }}
        value={postText}
        onChangeText={setPostText}
      />
      <Button
        title="Done"
        onPress={() => {
          // Pass and merge params back to home screen
          navigation.navigate({
            name: 'Home',
            params: { post: postText },
            merge: true,
          });
        }}
      />
    </>
  );
}

const Stack = createNativeStackNavigator();

export default function App() {
  return (
    <NavigationContainer>
      <Stack.Navigator mode="modal">
        <Stack.Screen name="Home" component={HomeScreen} />
        <Stack.Screen name="CreatePost" component={CreatePostScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}

//******************************************************************************


Riassunto
Puoi personalizzare l'intestazione all'interno del options supporto dei componenti dello schermo. 
Leggi l'elenco completo delle opzioni nel riferimento API .
L' option soggetto di scena può essere un oggetto o una funzione. Quando è una funzione, è dotata di un oggetto con navigatione routeprop.
È anche possibile specificare condivisa screenOptionsnella configurazione del navigatore dello stack al momento dell'inizializzazione. L'elica ha la precedenza su quella configurazione.

//*************************************************
Riassunto
È possibile impostare i pulsanti nell'intestazione tramite le proprietà headerLefte headerRightin options.
Il pulsante Indietro è completamente personalizzabile con headerLeft, ma se vuoi solo cambiare il titolo o l'immagine, ce ne sono altri optionsper quello — , , e . headerBackTitleheaderBackTitleStyleheaderBackImageSource
È possibile utilizzare una richiamata per le opzioni prop per accedere navigatione route oggetti.

//******************************************************

Migliori pratiche durante la nidificazione

Si consiglia di ridurre al minimo i navigatori di nidificazione. Cerca di ottenere il comportamento che desideri con il minor numero di annidamento possibile. La nidificazione ha molti aspetti negativi:

Ne risulta una gerarchia di viste profondamente nidificata che può causare problemi di memoria e prestazioni nei dispositivi di fascia bassa
Annidare lo stesso tipo di navigatori (ad es. schede all'interno delle schede, cassetto all'interno del cassetto ecc.) potrebbe creare confusione nell'esperienza utente
Con un annidamento eccessivo, il codice diventa difficile da seguire durante la navigazione verso schermate annidate, la configurazione di deep link ecc.
Pensa all'annidamento dei navigatori come un modo per ottenere l'interfaccia utente che desideri piuttosto che un modo per organizzare il tuo codice. Se si desidera creare un gruppo separato di schermate per l'organizzazione, invece di utilizzare navigatori separati, è possibile utilizzare il Groupcomponente.

<Stack.Navigator>
  {isLoggedIn ? (
    // Screens for logged in users
    <Stack.Group>
      <Stack.Screen name="Home" component={Home} />
      <Stack.Screen name="Profile" component={Profile} />
    </Stack.Group>
  ) : (
    // Auth screens
    <Stack.Group screenOptions={{ headerShown: false }}>
      <Stack.Screen name="SignIn" component={SignIn} />
      <Stack.Screen name="SignUp" component={SignUp} />
    </Stack.Group>
  )}
  {/* Common modal screens */}
  <Stack.Group screenOptions={{ presentation: 'modal' }}>
    <Stack.Screen name="Help" component={Help} />
    <Stack.Screen name="Invite" component={Invite} />
  </Stack.Group>
</Stack.Navigator>

//**********************************************************************

CICLO DI VITA 
Riassunto
Sebbene i metodi del ciclo di vita di React siano ancora validi, React Navigation aggiunge più eventi a cui puoi iscriverti tramite il navigationprop.
Puoi anche usare i ganci useFocusEffecto .useIsFocused

import { useFocusEffect } from '@react-navigation/native';

function Profile() {
  useFocusEffect(
    React.useCallback(() => {
      // Do something when the screen is focused

      return () => {
        // Do something when the screen is unfocused
        // Useful for cleanup functions
      };
    }, [])
  );

  return <ProfileContent />;
}

////////*******************************

Riassunto : handling-safe-area
Utilizzare react-native-safe-area-contextinvece di SafeAreaViewdareact-native
Non avvolgere l'intera app in SafeAreaView, avvolgere invece i contenuti all'interno degli schermi
Usa l' edgeselica per applicare un'area sicura su lati specifici
Usa il useSafeAreaInsetsgancio per un maggiore controllo su dove vengono applicati gli inserti

////////*******************************


COLORI DEFAULT -> Named colors implementation

aliceblue (`#f0f8ff`)
antiquewhite (`#faebd7`)
aqua (`#00ffff`)
aquamarine (`#7fffd4`)
azure (`#f0ffff`)
beige (`#f5f5dc`)
bisque (`#ffe4c4`)
black (`#000000`)
blanchedalmond (`#ffebcd`)
blue (`#0000ff`)
blueviolet (`#8a2be2`)
brown (`#a52a2a`)
burlywood (`#deb887`)
cadetblue (`#5f9ea0`)
chartreuse (`#7fff00`)
chocolate (`#d2691e`)
coral (`#ff7f50`)
cornflowerblue (`#6495ed`)
cornsilk (`#fff8dc`)
crimson (`#dc143c`)
cyan (`#00ffff`)
darkblue (`#00008b`)
darkcyan (`#008b8b`)
darkgoldenrod (`#b8860b`)
darkgray (`#a9a9a9`)
darkgreen (`#006400`)
darkgrey (`#a9a9a9`)
darkkhaki (`#bdb76b`)
darkmagenta (`#8b008b`)
darkolivegreen (`#556b2f`)
darkorange (`#ff8c00`)
darkorchid (`#9932cc`)
darkred (`#8b0000`)
darksalmon (`#e9967a`)
darkseagreen (`#8fbc8f`)
darkslateblue (`#483d8b`)
darkslategrey (`#2f4f4f`)
darkturquoise (`#00ced1`)
darkviolet (`#9400d3`)
deeppink (`#ff1493`)
deepskyblue (`#00bfff`)
dimgray (`#696969`)
dimgrey (`#696969`)
dodgerblue (`#1e90ff`)
firebrick (`#b22222`)
floralwhite (`#fffaf0`)
forestgreen (`#228b22`)
fuchsia (`#ff00ff`)
gainsboro (`#dcdcdc`)
ghostwhite (`#f8f8ff`)
gold (`#ffd700`)
goldenrod (`#daa520`)
gray (`#808080`)
green (`#008000`)
greenyellow (`#adff2f`)
grey (`#808080`)
honeydew (`#f0fff0`)
hotpink (`#ff69b4`)
indianred (`#cd5c5c`)
indigo (`#4b0082`)
ivory (`#fffff0`)
khaki (`#f0e68c`)
lavender (`#e6e6fa`)
lavenderblush (`#fff0f5`)
lawngreen (`#7cfc00`)
lemonchiffon (`#fffacd`)
lightblue (`#add8e6`)
lightcoral (`#f08080`)
lightcyan (`#e0ffff`)
lightgoldenrodyellow (`#fafad2`)
lightgray (`#d3d3d3`)
lightgreen (`#90ee90`)
lightgrey (`#d3d3d3`)
lightpink (`#ffb6c1`)
lightsalmon (`#ffa07a`)
lightseagreen (`#20b2aa`)
lightskyblue (`#87cefa`)
lightslategrey (`#778899`)
lightsteelblue (`#b0c4de`)
lightyellow (`#ffffe0`)
lime (`#00ff00`)
limegreen (`#32cd32`)
linen (`#faf0e6`)
magenta (`#ff00ff`)
maroon (`#800000`)
mediumaquamarine (`#66cdaa`)
mediumblue (`#0000cd`)
mediumorchid (`#ba55d3`)
mediumpurple (`#9370db`)
mediumseagreen (`#3cb371`)
mediumslateblue (`#7b68ee`)
mediumspringgreen (`#00fa9a`)
mediumturquoise (`#48d1cc`)
mediumvioletred (`#c71585`)
midnightblue (`#191970`)
mintcream (`#f5fffa`)
mistyrose (`#ffe4e1`)
moccasin (`#ffe4b5`)
navajowhite (`#ffdead`)
navy (`#000080`)
oldlace (`#fdf5e6`)
olive (`#808000`)
olivedrab (`#6b8e23`)
orange (`#ffa500`)
orangered (`#ff4500`)
orchid (`#da70d6`)
palegoldenrod (`#eee8aa`)
palegreen (`#98fb98`)
paleturquoise (`#afeeee`)
palevioletred (`#db7093`)
papayawhip (`#ffefd5`)
peachpuff (`#ffdab9`)
peru (`#cd853f`)
pink (`#ffc0cb`)
plum (`#dda0dd`)
powderblue (`#b0e0e6`)
purple (`#800080`)
rebeccapurple (`#663399`)
red (`#ff0000`)
rosybrown (`#bc8f8f`)
royalblue (`#4169e1`)
saddlebrown (`#8b4513`)
salmon (`#fa8072`)
sandybrown (`#f4a460`)
seagreen (`#2e8b57`)
seashell (`#fff5ee`)
sienna (`#a0522d`)
silver (`#c0c0c0`)
skyblue (`#87ceeb`)
slateblue (`#6a5acd`)
slategray (`#708090`)
snow (`#fffafa`)
springgreen (`#00ff7f`)
steelblue (`#4682b4`)
tan (`#d2b48c`)
teal (`#008080`)
thistle (`#d8bfd8`)
tomato (`#ff6347`)
turquoise (`#40e0d0`)
violet (`#ee82ee`)
wheat (`#f5deb3`)
white (`#ffffff`)
whitesmoke (`#f5f5f5`)
yellow (`#ffff00`)
yellowgreen (`#9acd32`)


///////////------------------------------------------

GENITORI FIGLI 

// as prop
<Parent children={() => <Child />} />

// "normal" syntax
<Parent>
  {() => <Child />}
</Parent>

// implementation
const Parent = ({ children }) => {
  return <>{children()}</>
}

///*********************************************

const Parent = () => {
  // Il rendering di Child verrà attivato quando Parent esegue nuovamente il rendering
  // poiché è incluso nel ritorno
  const child = <Child />;

  return <div>{child}</div>;
};

///********************************************

ChildE questo è ciò che consente alla memorizzazione di funzionare: se mi avvolgoReact.memo

const ChildMemo = React.memo(Child);

const Parent = () => {
  const child = <ChildMemo />;

  return <div>{child}</div>;
};

o memorizzare il risultato della chiamata di funzione

const Parent = () => {
  const child = useMemo(() => <Child />, []);

  return <div>{child}</div>;
};

l'oggetto definizione non verrà ricreato, React penserà che non ha bisogno di essere aggiornato e il rendering di Child non avverrà.
////*******************************

TEMPLATE LITERAL

const expressions = 'dynamic values';
const example = `I can contain ${expressions}`;

console.log(example);  // >> I can contain dynamic values
///////////////////////////////////


****>l'istruzione if...else... nella funzione di rendering di React?

*****> C'è una sezione nei documenti di React sul rendering condizionale a cui dovresti dare un'occhiata. Ecco un esempio di cosa potresti fare usando inline if-else.

render() {
  const isLoggedIn = this.state.isLoggedIn;
  return (
    <div>
      {isLoggedIn ? (
        <LogoutButton onClick={this.handleLogoutClick} />
      ) : (
        <LoginButton onClick={this.handleLoginClick} />
      )}
    </div>
  );
}

*****> Puoi anche gestirlo all'interno della funzione di rendering, ma prima di restituire jsx.

if (isLoggedIn) {
  button = <LogoutButton onClick={this.handleLogoutClick} />;
} else {
  button = <LoginButton onClick={this.handleLoginClick} />;
}

return (
  <div>
    <Greeting isLoggedIn={isLoggedIn} />
    {button}
  </div>
);


****> Vale anche la pena menzionare ciò che ZekeDroid ha sollevato nei commenti. Se stai solo verificando una condizione e non vuoi eseguire il rendering di un particolare pezzo di codice che non è conforme, puoi utilizzare && operator.

  return (
    <div>
      <h1>Hello!</h1>
      {unreadMessages.length > 0 &&
        <h2>
          You have {unreadMessages.length} unread messages.
        </h2>
      }
    </div>
  );


  *********
  Rendering completo della funzione in REACT

const renderbase = ({datalist}) => {
        if(datalist){
            return  Object.keys(datalist).map((item,index) => {
                return(
                  <option value={datalist[item].code} key={index}>
                      {datalist[item].symbol}
                  </option>
                )
            })
        }  
    }

-------
a = { 
  a: 1,
  b: 2,
  c: 3
}

Object.entries(a).map(([key, value]) => {
    // Abbastanza semplice: usa la chiave per la chiave e il valore per il valore.
    // Giusto per chiarire: a differenza della destrutturazione degli oggetti, i nomi dei parametri non contano qui.
})




  // Object.entries(colorMe[1]).map((colorMe2, index2) => {
                //   {
                //     console.log(`colorMe2[1], ${colorMe2[1]}`);
                //   }
                //   <BoxStl
                //     key={`2_BoxStl ${index}`}
                //     style={{ backgroundColor: colorMe2[1] }}
                //   >
                //     <TextStl
                //       key={`3_TextStl ${index}`}
                //       style={{
                //         fontSize: typography.fontSize.H6,
                //         textAlign: "center",
                //         color: props.THEME.coloriTema.PRIMARY_TEXT_COLOR,
                //       }}
                //     >
                //       {colorMe2[1]} BOOO
                //     </TextStl>
                //   </BoxStl>;
                // })